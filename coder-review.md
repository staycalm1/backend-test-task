# src/Repository

## src/Repository/Entity/Product.php

1. Судя по миграции `migrations/schema.init.sql`, поля `description` и `thumbnail` могут принимать значение `NULL`. Однако, в конструкторе эти поля объявлены, как `string`. Нужно разрешить `NULL` значения в классе (или запретить их в БД).

## src/Repository/CartManager.php

1. Логгер устанавливается функцией `setLogger`, а не добавляется через конструктор. Теоретически, при попытке логирования, может возникнуть ошибка.
2. Лучше или изменить текст ошибки, или добавить контекст, чтобы было понятнее, что произошло.
3. Перепутан порядок аргументов в вызове метода `set` в коннекторе.
4. `Raketa\BackendTestTask\Infrastructure\ConnectorException` наследуется от `Throwable`. Получается, в `try-catch` блоке он не ловится, и в логи не попадает. Это так задумано? Возможно, стоит вместо `Exception` поставить `Raketa\BackendTestTask\Infrastructure\ConnectorException`?
5. Не очень понятна логика работы `getCart`. Если нужно, чтобы функция всегда возвращала корзину, даже если `Redis` недоступен/корзина не найдена, то нужно каким то образом передать все нужные для создания корзины данные (потому что сейчас их не хватает).
   Или вынести логику обработки ошибок в другой класс (в потребитель `Raketa\BackendTestTask\Repository\CartManager`), у которого будет больше информации
   и который сможет обработать такую ситуацию.
6. Возможно, напутаны PHPDocs. `@inheritdoc` никого не наследует. `?Cart` лучше вынести в возвращаемый тип (если решили, что класс `Raketa\BackendTestTask\Repository\CartManager` не будут обрабатывать такую ситуацию).
7. `saveCart` не возвращает ничего. Лучше бы, конечно, прокинуть статус из `Raketa\BackendTestTask\Infrastructure\Connector@set`.
8. Возможно, в конструктор лучше передавать готовый `Raketa\BackendTestTask\Infrastructure\Connector $connector`? Сейчас логика работы кажется неоднозначной. 
   А выбор конкретной базы можно попробовать реализовать в момент создания и настройки `Raketa\BackendTestTask\Infrastructure\Connector`. В крайнем случае, можно передать фабрику, если есть несколько подключений (разные базы) и `Raketa\BackendTestTask\Repository\CartManager` должен сам решать, какое в конкретной ситуации использовать.

## src/Repository/ProductRepository.php

1. Лучше использовать параметризованные запросы, иначе от недоверенных строковых аргументов есть шанс получить SQL-инъекцию.
2. Метод `getByUuid` выкидывает `Exception` в случае, если модель не найдена. Возможно, лучше просто вернуть `NULL`, а исключения оставить для других ситуаций.
3. `fetchOne` вернёт только значение первого поля первой записи. Нужно использовать `fetchAssociative`.
4. Анонимная функция объявлена `static`, поэтому доступа к `$this` у неё не будет. Лучше убрать `static`.
5. В функции `make` лучше использовать именнованные аргументы, чтобы не перепутать порядок.
6. В `getByCategory` в выборке фигурирует только `id`, чего недостаточно для создания модели продукта. 

# src/Infrastructure

## src/Infrastructure/ConnectorFacade.php

1. Лучше переписать на `Raketa\BackendTestTask\Infrastructure\ConnectorFactory` и использовать либо в самом `Raketa\BackendTestTask\Repository\CartManager`, либо при настройке `DI`.
2. Если используется `php-fpm`, то вместо метода `connect` лучше использовать `pconnect`, чтобы сохранить подключение к `redis` активным.
3. Свойства лучше сделать приватными.

## src/Infrastructure/Connector.php

1. Логику подключения лучше реализовать в самом `Raketa\BackendTestTask\Infrastructure\Connector`, т.к. в любом случае нужно проверять, активно ли подключение, или нет.
2. Лучше обернуть вызовы функций в `retry` + сделать отложенную инициализацию клиента.
3. Возможно, стоит использовать другую логику сериализации? Например, в `json`.
   Во-первых, классы могут быть переименованы.
   Во-вторых, эти данные, теоретически, могут использоваться ещё где то.

## src/Infrastructure/ConnectorException.php

1. Добавить `null-safe` оператор для `$this->previous`.

# src/View

## src/View/CartView.php

1. Некорректно считается `total` для позиций в корзине.
2. `getCustomer()` можно сохранить в переменную, чтобы не вызывать функцию по несколько раз.
3. На тот случай, если `getLastName()`, `getFirstName()` или `getMiddleName()` могут вернуть пустую строку, лучше обернуть массив в `array_filter`.
4. Для работы с деньгами лучше использовать библиотеку `bcmath`.

## src/View/ProductsView.php

1. Название продукта вам не нужно возвращать?

# src/Controller

## src/Controller/AddToCartController.php

1. Не вызывается `saveCart`.
2. Лучше добавить обработку ошибок.
3. Возможно, стоит вынести логику создания `Raketa\BackendTestTask\Domain\CartItem` из контроллера. Это, скорее всего, не единственное место, где может создаваться новая позиция для корзины.
4. Даже если базовая валидация уже была проведена, всё равно лучше ещё раз проверить, что продукт получилось найти в репозитории (это если всю эту логику оставлять в контроллере).
5. Можно вынести общую логику формирования ответа в класс `Raketa\BackendTestTask\Controller\JsonResponse`.
6. Стоит добавить логирование внутри контроллера. Ну или хотя бы настроить `Raketa\BackendTestTask\Repository\CartManager` для логирования ошибок корзины (при это ошибки репозитория продуктов останутся необработанными).

## src/Controller/GetCartController.php

1. Лишний `else`.
2. Свойства лучше объявить как `private`.
3. Напутаны статусы ответа - корзина возвращается с 404 статусом.
4. Добавить обработку ошибок + логирование.

## src/Controller/GetProductsController.php

1. Добавить обработку ошибок + логирование.

## src/Controller/JsonResponse.php

1. Возможно, стоит добавить базовый метод `fromArray`, т.к. много однотипного кода. Можно пойти чуть дальше и добавить фабричные методы вроде `error`, `success`, `unavailable`.

# Разное

1. В миграции `migrations/schema.init.sql`, для поля `uuid` тип `varchar(255)` избыточен. В миграциях Laravel для MySQL для поля `uuid` используется тип `char(36)`.
2. В миграции `migrations/schema.init.sql` создаётся индекс `is_active_idx` для поля `is_active`. Не факт, что он будет использоваться БД в реальных запросах.